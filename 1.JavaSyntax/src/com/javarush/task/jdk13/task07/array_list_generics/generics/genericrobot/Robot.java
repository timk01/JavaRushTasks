package com.javarush.task.jdk13.task07.array_list_generics.generics.genericrobot;

public class Robot<T extends Head> {
    private Body body;
    private T specificHead;

/*    public void foo2() {
        //specificHead. ничего нельзя вызвать у типа, только методы класса обжект. (даже прибавить +1 нельлья)

    }*/

    public <T1, T2 extends Head> T2 foo(T1 a, T2 b) {
        //T1 a = new T1(); //так нельзя: непонятно что это такое T1
        //но и складывать, проводить манипуляции... ничего мы же может кроме класса обжект
        return b;
    }

    public Robot<?> foo3(Robot<?> obj) {
        //даже так можно сделать, когда нам все равно что в робота передается
        return obj;
    }

    public Robot(Body body, T specificHead) {
        this.body = body;
        this.specificHead = specificHead;
    }

    public Body getBody() {
        return body;
    }

    public void setBody(Body body) {
        this.body = body;
    }

    public T getSpecificHead() {
        return specificHead;
    }

    public void setSpecificHead(T specificHead) {
        this.specificHead = specificHead;
    }
}

/*
Если делать "в лоб", будет 3 вариации робота - по 1 на каждую голову (их же 3 разных в конце-концов
Если еще и 3 тела - уже 9. А это 9 разных классов!
Какие варианты ? 1. Создать общего предка (Голова) и отнаследоваться от него.
в мейне соответственно создаем 3 головы, 1 тело и пихаем например 1 голову и тело в конструктор
ОК. теперь, например у голов разный функционал. 1 - жжет, 2 говорит, 3 вертится

robot.getSpecificHead().
но... нельзя вызвать специфический для головы метод
(что и логично: в голове нет такого метода, а из класса-родителя его не видно)
вариантов немного. например сунуть все методы в класс-предок... но тэо тоже неверно,
т.к. маленькая голова только жжет (говорить, вращаться не умеет); и наоборот
что делать ?

Параметризировать. голову. Robot меняем на Robot<T> (это голова), в полях вместо Head суем Т
Это мы объявили параметр и дальше его используем
Robot<SmallHead> robot = new Robot<SmallHead>(body, smallHead);
теперь - уже так.
когда мы создаем робота, этот тип SmallHead передается внутрь класса в качстве Т, и если там это был
неопределенный тип, то сейчас он КОНКРЕТНЫЙ (он присваивается параметрам класса и может использоваться далее)


есть определенные проблемы при работе с такими данными. см. метод foo2()
второй момент - нельзя сделать robot = robot1; 2 объекта фактически паметризивоны разными вещами
а если создать сырой тип - будет обжект (см. Мейн)

третий момент. создадим ногу. см. Мейн. Выглядит странно да ?
Поэтому используется ключевое слово extends на параметры: T extends Head
 */

/*
Теперь. Про параметризированные методы. Они вообще могут быть без парметризированных классов! На примере foo
параметры объявляются после всех модификаторов, но ДО возвращаемого значения (как в классе короче)
и потом эти параметры можно использовать (использовать внутри метода и/или в качестве принимаемых парметров)
например, вместо войда (о нем возже)
будет возвращаемый парметр... T2. Можно представить конкретный ТИП, например Стринг или Интежер
см. foo2

также смотри foo3
 */