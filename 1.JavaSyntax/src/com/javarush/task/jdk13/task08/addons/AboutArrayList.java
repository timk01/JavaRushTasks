package com.javarush.task.jdk13.task08.addons;

public class AboutArrayList {
    public static void main(String[] args) {
    }
}

/*
Динамически расширяемый массив (под капотом - массив, макс. вместимость и текущий размер как поля)
Непрерывный блок памяти (т.е. элементы расположены один за другим)
, когда ндао вставить внутрь, после проверки разницы текущей длины и максимальной вместимости

Вставка.

Тут, если места еще есть (незанятые реальными значениями), добавляется в конец. add (elem) (аналог add(size-1, elem))
Если нет, создается бОльший массив в 1.5 раза (изменяется значение максимальной вместимости),
туда копируются все элементы старого, добавляется новый элемент в конец; значение текущий размер: +1 элемент
Добавление (именно в конец) O(1) - потому что ничего сдвигать и не надо.
Разве что раздвинуть пределы старого массива, но операция СистемКопи и она быстрая.

Добавление в середину (или тем более начало) - надо _не просто скопировать все элементы в новый массив_,
а сдвинуть их в прцоессе к следующему (т.е. скопировать на позицию +1):
Т.е. копируем часть, вставляем элемент, копируем остальные элементы на +1 позицию от нашего вновь "впихнутого"
Процесс медленней и в худшем (даже среднем случае) O(n), т.к. нужно пробежаться по всему массиву.

Удаление:
1) обнулить элемент удаляемый;
2) Сдвинуть объекты после этой точки (если из середины);
3)текущий размер уменьшить на 1
Уменьшать вместимость не надо
(и это одна из потенциальных проблем при создании массива скажем с большой капасити и удаления множества элементов
- см. метод trimToSize())
Снова самый "легкий" вариант - с конца (O(1), тяжелый - с начала

ВЫВОД: arrayList удобен, когда нужно получать что-то по индексу, либо удалять/добавлять. НО с конца.
Если нужно работать с серединой АЛ, нужно посмотреть в сторону... например ЛЛ
Как и в АЛ, в ЛЛ contains - O(n) - придется перебрать все элементы массива и сравнить с тем, что ищем...
 */